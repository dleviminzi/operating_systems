<html>
<head>
<title>Project 3A</title>
</head>

<body>
<center>
<h1>File System Interpretation</h1>
</center>

<h2>INTRODUCTION:</h2>
<p>
We are all familiar with the characteristics of the files and directories
in which we store all of our data.  As with many other persistent objects,
their functionality, generality, performance and robustness all derive 
from the underlying data structures used to implement them.  
In this project we will design and implement a program to read the on-disk
representation of a file system, analyze it, and summarize its contents.
In the next project, we will write a program to analyze this
summary for evidence of corruption.
</p>
This project can be broken into two major steps:
<ul>
   <li>	Understand the on-disk data format of the EXT2 file system.
   	We will mount a provided image file on your own Linux system and 
	explore it with familiar file navigation commands and <em>debugfs(8)</em>.</li>
   <li> Write a program to analyze the file system in that
   	image file and output a summary to standard out
   	(describing the super block, groups, free-lists, inodes, indirect blocks, 
	and directories).  </li>
</ul>
The second part may involve much more code than we have written in
previous projects, 
but the first part is (by far) the more difficult.
Once the underlying data structures are understood,
the actual code is likely to be fairly simple.
<p></p>
<h2>RELATION TO READING AND LECTURES:</h2>
<p>
This project more deeply explores the filesystem structures described in
Arpaci chapter 39.<br>
The images we will be working with are EXT2 file systems,
as described in sections 40.2-40.5.
</p>
The lectures on file systems, file system performance, and reliability describe
why data structures like those in this project are used to manage file systems.

<p></p>
<h2> PROJECT OBJECTIVES:</h2>
<ul>
   <li>	Primary: reinforce the basic file system concepts of directory objects,
   	file objects, and free space.</li>
   <li>	Primary: reinforce the implemenation descriptions provided in the text 
   	and lectures.</li>
   <li> Primary: gain experience researching, examining, interpreting and processing
   	information in complex binary data structures.</li>
   <li> Primary: gain experience with examining interpreted and raw hex dumps 
   	of complex data structures as a means of developing an understanding
	of those data structures.</li>
   <li> Secondary: gain practical experience with typical on-disk file
   	system data formats.</li>
</ul>
<p></p>
<h2> DELIVERABLES:</h2>
<p>
A single tarball (<tt>.tar.gz</tt>) containing:
<ul>

   <li> (at least) one C/C++ source module that compiles cleanly with no errors or warnings).</li>
   <p></p>
   <li> A <tt>Makefile</tt> to build and run the deliverable program.
	The higher level targets should be:
	<ul>
	   <li> default ... compile your program 
	        (with the <strong><tt>-Wall</tt></strong> and 
	        <strong><tt>-Wextra</tt></strong> options)
	        to produce an executable named <tt>lab3a</tt></li>
	   <li> <strong>dist</strong> ... create the deliverable tarball</li>
	   <li> <strong>clean</strong> ... delete all programs and output
	   	generated by the <tt>Makefile</tt>.</li>
	</ul>
    </li>
   <p></p>
    <li>a <tt>README</tt> text file containing
	 descriptions of each of the included files and any other information 
	     about your submission that you would like to bring to our attention 
	 (e.g., research, limitations, features, testing methodology).</LI>
</ul>
<p></p>

<h2> PROJECT DESCRIPTION:</h2>
<P>
Historically, file systems were almost always been implemented as 
part of the operating system, running in kernel mode.  
Kernel code is expensive to develop, difficult to test, 
and prone to catastrophic failures.  
Within the past 15 years or so, new developments have made it 
possible to implement file systems in user mode, 
improving maintainability, and in some cases 
delivering even better performance than could be achieved 
with kernel code.  
All of this project will be done as user-mode software.
</p>
<P>
To ensure data privacy and integrity, file system disks are generally 
protected from access by ordinary applications.  
Linux supports the creation, mounting, checking, 
and debugging of file systems stored in ordinary files.  
In this project, we will provide EXT2 file system 
images in ordinary files.  
Because they are in ordinary files (rather than protected disks) 
you can access/operate on those file system images with ordinary 
user mode code.
</p>
<h3>PREPARATION</h3>
<p>
To perform this assignment, you may need to study a few things:
<ul>
   <li>	<a href="http://man7.org/linux/man-pages/man8/debugfs.8.html">debugfs(8)</A>,
   	a tool for exploring on-disk file system structures.</li>
   <li>	<a href="http://man7.org/linux/man-pages/man2/pread.2.html">pread(2)</A>,
   	an alternative to <em>read(2)</em> for random-access file processing.</li>
   <li> a comprehensive overview of the
   	<a href="http://www.nongnu.org/ext2-doc/ext2.html">EXT2</A> file system format.</li>
   <li> a slightly simplified version of the Linux
   	<a href="ext2_fs.h">header file</a> that defines the format of the EXT2 file system.
	Do not assume that the standard header file will be available on the test system.  
	Please use this header file and include it in your submission. 
	You cannot modify this header file, but you are free to add new files of your own.
	</li>
</ul>
<p></p>
<h3>PART 1: Exploring an EXT2 Image</h3>
<P>
In order to mount and explore a file system (even one stored in an ordinary file)
you will need the ability to run privileged commands (e.g., <em>mount(8)</em>).
Since you will not have <em>sudo(8)</em> access on SEASnet servers, 
you will have to do this exploration on your own personal Linux system.
</p>
<P>
Download the (1-2MB) EXT2_test.img file in the project web page
and mount it (read only) onto your own Linux system, with the following commands:
<pre><tt>
	mkdir fs
	sudo mount -o ro,loop EXT2_test.img fs
</tt></pre>
The <tt>loop</tt> option means that the file system image is stored in a file
rather than on a device.
The <tt>ro</tt> option means <strong>read only</strong>, to prevent you
from accidentally changing the image.
<p>
Now, you can navigate the file system, just like an ordinary directory, 
with commands like <em>ls(1)</em>, <em>cat(1)</em>, and <em>cd(1)</em>. 
After you are done with it, you can unmount with the following command:
<pre><tt>
	sudo umount fs
</tt></pre>
</P>
<P>
Before you start writing your C/C++ program to interpret the diskimage file, 
you can explore it further using <em>debugfs(8)</em> (on your own Linux system). 
You will, in the process of writing your code,
surely encounter many questions about how to interpret
the values in various fields.
Reading the specifications is seldom enough to enable us to fully 
understand complex data structures.
Welcome to the real world!
Learning how to complement research with examination and experimentation 
to understand a complex system is a skill that you are expected to develop and
demonstrate in this project.
The supplied images and exploration tools can 
be used to examine real instances of super blocks, group
summaries, I-nodes, directories, etc.
</P>
<P>
Some particularly helpful <em>debugfs(8)</em> commands are: 
<tt>stats</tt>, <tt>stat</tt>, <tt>bd</tt>, <tt>testi</tt>, and <tt>testb</tt>.  
While <em>debugfs</em> can interpret data structures for you, you may
find that a simple hex dump of the associated block provides you with
more detailed information.
</P>
<H4>Warnings</H4>
<P>
If you mount the <tt>trivial.img</tt> image read/write, even read
commands (like <em>ls(1)</em>) will cause changes to I-node access
times.  If you want to be able to compare your analysis with the
golden <tt>trivial.csv</tt> output we have provided, you must work
from an unmodified version of <tt>trivial.img</tt>.
</P>
<P>
To ensure you are correctly interpreting the file system image, 
we have included many unusual things, which might not be properly
handled by a naive implementation:
<ul>
   <li>	sparse files with large unallocated areas between allocated blocks</li>
   <li>	very large files</li>
   <li>	allocated data blocks full of zeroes</li>
   <li>	unallocated blocks containing valid data</li>
   <li>	files with data beyond their length</li>
   <li>	files with long names</li>
   <li>	files with syntactically strange or non-ASCII names</li>
   <li>	directories that span multiple blocks, go beyond the direct blocks, and have obsolete entries for deleted files</li>
</ul>
All of these are completely legal and do not represent any sort of corruption.
</P>
<h3>PART 2: Summarizing an EXT2 Image</h3>
<P>
In this step, you will write a C/C++ program called <tt>lab3a</tt> that:
<ul>
   <li>	Reads a file system image, whose name is specified as a command line argument. 
	For example, we may run your program with the above file system image 
	using the a command like: 
	<pre><tt>
	./lab3a EXT2_test.img
	</tt></pre>
   </li>
   <li> Analyzes the provided file system image and produces
   	(to standard out) CSV summaries of what it finds.
   	The contents of these CSV lines
	described below. Your program must output these 
	files with exactly the same formats as shown below. 
	We will use <em>sort(1)</em> and <em>diff(1)</em> to 
	compare your csv output with ours, 
	so the order of output lines does not matter, 
	but a different format (even extra white space) will make your 
	program fail the test.
   </li>
</ul>
<p>
Please note that, even if you cannot mount the provided image 
file and run <em>debugfs</em> on SEASnet servers, 
your lab3a program should, like previous assignments, be able 
to run on SEASnet servers.
</p>
<P>
There are six types of output lines that your program should produce,
each summarizing a different part of the file system.  
Remember, you can always check your program's output against 
<em>debugfs</em>'s output.
All the information required for the summary can be manually 
found and checked by using debugfs.
We have also included (for testing purposes) a much smaller
<a href="trivial.img">image</a>
as well as a correct
<a href="trivial.csv">output summary</a>.
</p>
<P>
You are free to produce additional commentary to stderr, but
only file system summary information should be logged to stdout.
</P>

<h4>superblock summary</h4>
<P>
A single new-line terminated line, comprised of eight comma-separated fields (with no white-space),
summarizing the key file system parameters:
</p>
<ol type="1">
   <li> <tt>SUPERBLOCK</tt> </li>
   <li> total number of blocks (decimal)</li>
   <li> total number of i-nodes (decimal)</li>
   <li> block size (in bytes, decimal)</li>
   <li> i-node size (in bytes, decimal)</li>
   <li> blocks per group (decimal)</li>
   <li> i-nodes per group (decimal)</li>
   <li> first non-reserved i-node (decimal)</li>
</ol>

<h4>group summary</h4>
<P>
Scan each of the groups in the file system.
For each group, produce
a new-line terminated line for each group, each comprised of nine comma-separated fields
(with no white space), summarizing its contents.
</p>
<ol type="1">
   <li> <tt>GROUP</tt> </li>
   <li> group number (decimal, starting from zero)</li>
   <li>	total number of blocks in this group (decimal)</li>
   <li> total number of i-nodes in this group (decimal)</li>
   <li>	number of free blocks (decimal) </li>
   <li>	number of free i-nodes (decimal) </li>
   <li>	block number of free block bitmap for this group (decimal) </li>
   <li>	block number of free i-node bitmap for this group (decimal) </li>
   <li>	block number of first block of i-nodes in this group (decimal) </li>
</ol>
<P>
Note that most Berkeley-derived file systms (like EXT2) support both blocks
and fragments, which may have different sizes.  The block is the preferred
unit of allocation.  But in some cases, fragments may be used (to reduce
internal fragmentation loss).  Block addresses and the free block list 
entries are based on the fragment size, rather than the block size.
But, in the images we give you, the block and fragment sizes will 
be the same.
</P>
<P>
One of the major features included EXT2 file systems is support for multiple 
cylinder groups:
<ul>
   <li> all cylinder groups but the last have the same number of blocks
        and I-nodes; the last has the residue (e.g., blocks/fs modulo blocks/group).</li>
   <li> each group, in addition to its group summary, also (for redundancy) 
        starts with a copy of the file system superblock.</li>
</ul>
But, in the images we give you, there will be only a single group.
</p>

<h4>free block entries</h4>
<P>
Scan the free block bitmap for each group.
For each free block, produce
a new-line terminated line,
with two comma-separated fields
(with no white space).
</p>
<ol type="1">
   <li> <tt>BFREE</tt> </li>
   <li> number of the free block (decimal)</li>
</ol>
<P>
Take care to verify that you:
<ol type=="a">
   <li>understand whether 1 means allocated or free.</li>
   <li>have correctly understood the block number to which the first bit corresponds.</li>
   <li>know how many blocks are in each group, and do not interpret more bits than there are blocks in the group.</li>
</ol>
</P>

<h4>free I-node entries</h4>
<P>
Scan the free I-node bitmap for each group.
For each free I-node, produce
a new-line terminated line,
with two comma-separated fields
(with no white space).
</p>
<ol type="1">
   <li> <tt>IFREE</tt> </li>
   <li> number of the free I-node (decimal)</li>
</ol>
<P>
Take care to verify that you:
<ol type=="a">
   <li>understand whether 1 means allocated or free.</li>
   <li>have correctly understood the I-node number to which the first bit corresponds.</li>
   <li>know how many I-nodes are in each group, and do not interpret more bits than there are I-nodes in the group.</li>
</ol>
</P>

<h4>I-node summary</h4>
<P>
Scan the I-nodes for each group.
For each allocated (non-zero mode and non-zero link count) I-node, produce a
new-line terminated line, with up to 27 comma-separated
fields (with no white space).  The first twelve fields are i-node attributes:
</p>
<ol type="1">
   <li><tt>INODE</tt></li>
   <li>inode number (decimal)</li>
   <li>file type ('f' for file, 'd' for directory, 's' for symbolic link, '?" for anything else)</li>
   <li>mode (low order 12-bits, octal ... suggested format "%o")</li>
   <li>owner (decimal)</li>
   <li>group (decimal)</li>
   <li>link count (decimal)</li>
   <li>time of last I-node change (mm/dd/yy hh:mm:ss, GMT)
   <li>modification time (mm/dd/yy hh:mm:ss, GMT)
   <li>time of last access (mm/dd/yy hh:mm:ss, GMT)
   <li>file size (decimal)</li>
   <li>number of (512 byte) blocks of disk space (decimal) taken up by this file</li>
</ol>
<p>
The <em>number of blocks</em> (field 12) should contain the same value as the <em>i_blocks</em> field of the I-node.
There are a few interesting and non-obvious things about this number:
<ol>
   <li> This number is in units of 512 byte blocks, even if the file system block size is something
        else (e.g. 1024 or 4096 byte blocks).</li>
   <li> This number (times 512) may be smaller than the file size, as it includes only blocks that have
        actually been allocated to the file.   A very large file might be 
	<a href="https://en.wikipedia.org/wiki/Sparse_file">sparse</a>, 
	in that some parts of the file may not have actually been written, 
	and take up no disk space, but will read back as zeroes.
        </li>
   <li> This number (times 512) may be larger than the file size because it includes not only
   	data blocks, but (single, double, and tripple) indirect blocks that point to data blocks.
    	</li>
</ol>
</p>
<P>
For ordiary files (type 'f') and directories (type 'd') the next fifteen fields 
are block addresses 
(decimal, 12 direct, one indirect, one double indirect, one triple indirect).  
</P>
<P>
Symbolic links may be a little more complicated.  
If the file length is less than or equal to the size of the block pointers (60 bytes) the 
file will contain zero data blocks, and the name is stored in the space normally 
occupied by the block pointers.  If this is the case, the fifteen block pointers should
not be printed.  If, however, the file length is greater than 60 bytes, print out the 
fifteen block nunmbes as for ordinary files and directories.
</P>

<h4>directory entries</h4>
<P>
For each directory I-node, scan every data block.  For each valid (non-zero I-node number) 
directory entry,
produce a new-line terminated line, with seven comma-separated fields (no white space). 
</p>
<ol type="1">
   <li><tt>DIRENT</tt></li>
   <li> parent inode number (decimal) ... 
   	the I-node number of the directory that contains this entry</li>
   <li> logical byte offset (decimal) of this entry within the directory</li>
   <li> inode number of the referenced file (decimal)</li>
   <li> entry length (decimal)</li>
   <li> name length (decimal)</li>
   <li> name (string, surrounded by single-quotes).  
	Don't worry about escaping, we promise there will be no
	single-quotes or commas in any of the file names.
       </li> 
</ol>

<h4>indirect block references</h4>
<P>
The I-node summary contains a list of all 12 blocks, and the primary single, 
double, and triple indirect blocks.  We also need to know about the blocks
that are pointed to by those indirect blocks.
For each file or directory I-node, scan the single indirect blocks and (recursively) the double and triple indirect blocks.  For each non-zero block pointer you find, produce
a new-line terminated line with six
comma-separated fields (no white space).
</p>
<ol type="1">
   <li> <tt>INDIRECT</tt></li>
   <li> I-node number of the owning file (decimal)</li>
   <li> (decimal) level of indirection for the block being scanned ... 1 for single indirect, 2 for double indirect, 3 for triple</li>
   <li> logical block offset (decimal) represented by the referenced block. 
   	If the referenced block is a data block, this is the logical block offset of that block within the file.
	If the referenced block is a single- or double-indirect block, this is the same as the logical offset 
	of the first data block to which it refers.</li>
   <li>	block number of the (1, 2, 3) indirect block being scanned (decimal) . . . not the highest
   	level block (in the recursive scan), but the lower level block that contains the
	block reference reported by this entry.</li>
   <li> block number of the referenced block (decimal)</li>
</ol>
<P>
<em>Logical block</em> is a commonly used term.
It ignores physical file structure (where data is actulally stored, indirect blocks, sparseness, etc) 
and views the data in the file as a (logical) stream of bytes.  
If the block size was 1K (1024 bytes):
<ul>
   <li> bytes 0-1023 would be in logical block 0</li>
   <li> bytes 1024-2047 would be in logical block 1</li>
   <li> bytes 2048-3071 would be in logical block 2</li>
   ...
</ul>
You can confirm your understanding of logical block numbers by looking at 
the <tt>INDIRECT</tt> entries in the sample output.
</P>
<P>
If an I-node contains a triple indirect block:
<ul>
   <li> the triple indirect block number would be included in the INODE summary.</li>
   <li> <tt>INDIRECT</tt> entries (with level 3) would be produced for each double indirect
        block pointed to by that triple indirect block.</li>
   <li> <tt>INDIRECT</tt> entries (with level 2) would be produced for each indirect block
        pointed to by one of those double indirect blocks.</li>
   <li> <tt>INDIRECT</tt> entries (with level 1) would be produced for each data block 
        pointed to by one of those indirect blocks.</li>
</ul>
</P>

<h4>Sample Output</h4>
<P>
We have provided a very simple test file system 
<a href="trivial.img">image</a>
as well as a correct
<a href="trivial.csv">output summary</a>
that you can download and test with.
Your program should be able to generate (modulo line ordering) the same output.
The grading program will run your program on a variety of other file system images,
and check whether or not your output is <u>identical</u> to the golden output.
Any differences (even white space or a case error) will result in a loss of all
points for that test.
</p>

<H2> SUMMARY OF EXIT CODES: </H2>
<ul>
   <li> 0 . . . analysis successful </li>
   <li> 1 . . . bad arguments </li>
   <li> 2 . . . corruption detected or other processing errors</li>
</ul>

<h2> SUBMISSION: </h2>
<P>
Your <strong>README</strong> file must include lines of the form:
<ul>
	<strong>NAME:</strong> <em>your (comma separated) name(s)</em><br>
	<strong>EMAIL:</strong> <em>your (comma separated) email(s)</em><br>
	<strong>ID:</strong> <em>your (comma separated) student ID(s)</em>
</ul>
Your name, student ID, and email address  should also appear as comments at the top
of your <tt>Makefile</tt> and each source file.  
Your ID should be in the XXXXXXXXX format, not the XXX-XXX-XXX format.
If this is a team submission, the
names, e-mail addresses, and student IDs should be comma-separated.
</P>
<p>
Your tarball should have a name of the form <tt>lab3a-</tt><em>studentID</em><tt>.tar.gz</tt>.
If you are doing this project as a team submission, either of your student ID numbers can be used.
</p>
<P>
You can sanity check your submission with this 
<A href="P3A_check.sh">test script</A>.
There will be no manual re-grading on this project. 
Submissions that do not pass the test script are likely to receive very low scores.
Note that the sanity check runs are timed.  If your program is implemented inefficiently
(e.g. too many scans, using too much memory) it may run so slowly as to time out and fail.
If this happens to you, examine your approach and look for a more efficient way to
obtain the required information.
Also note that passing this sanity check does not guarantee a 100% score on the project. You are responsible for testing your own code, and the sanity check script is merely one tool for testing, not a guarantee that everything is correct.
</p>
<p>
We will test your submission on a <A HREF="https://www.seasnet.ucla.edu/lnxsrv/">SEASnet Linux server</A>.
Because of permissions issues, you will be unlikely to be able to test your
submissions on those servers.  We will, as a result, be slightly more lenient
in dealing with server-specific issues than on other projects.  However,
any issues
related to versions of compilers, libraries, or other software you use in
the project must be solved by you.  Be sure that the SEASnet servers that
the project will be tested on use software versions compatible with those
in your submission.  Those grading the projects 
<strong>will not</strong> fix these problems for you.
</p>
<P>
You may add files not specified in this page into the tarball for your submission, if you feel they are helpful. If you do so, be sure to mention each such file by name in your README file. Also be sure they are properly handled during the dist and clean operations in your Makefile.
</P>

<h2> GRADING: </h2>
<P>
Points for this project will be awarded:
</P>
<div align="center">
<table><tbody>
<tr> <th>value</th>	<th align="left">feature</th></tr>

<tr> <td></td>		<th align="left">Packaging and build (10% total)</th></tr>
<tr> <td>3%</td>	<td>un-tars expected contents</td></tr>
<tr> <td>3%</td>	<td>clean build with default action (no warnings)</td></tr>
<tr> <td>2%</td>	<td>correct <tt>clean</tt> and <tt>dist</tt> targets</td></tr>
<tr> <td>2%</td>	<td>reasonableness of <tt>README</tt> contents</td></tr>

<tr> <td></td> </tr>
<tr> <td></td>		<th align="left">Results (85% total)</th></tr>
<tr> <td>10%</td>	<td>superblock summary</td></tr>
<tr> <td>10%</td>	<td>group summaries</td></tr>
<tr> <td>10%</td>	<td>free block entries</td></tr>
<tr> <td>10%</td>	<td>free I-node entries</td></tr>
<tr> <td>15%</td>	<td>I-node summaries</td></tr>
<tr> <td>15%</td>	<td>directory entries</td></tr>
<tr> <td>15%</td>	<td>block references</td></tr>

<tr> <td></td> </tr>
<tr> <td></td>		<th align="left">Code Review (5%)</th></tr>
<tr> <td>5%</td>	<td>general organization and readability</td></tr>

</tbody></table>
</div>

</body>
</html>
